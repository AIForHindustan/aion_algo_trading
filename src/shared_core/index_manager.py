"""
Index Manager - Single source of truth for index prices and mapping
Optimized for high-frequency websocket parsing

INITIALIZATION:
===============
This module exports a singleton `index_manager` which auto-initializes on first import.
No separate startup script is required.

    from shared_core.index_manager import index_manager

On initialization, it loads index configuration from:
    zerodha/crawlers/binary_crawler1/intraday_crawler_instruments.json

For each process (especially multiprocessing workers), you must connect Redis:
    index_manager.connect_redis(redis_client)  # Enables fallback price lookups

SPOT PRICE DATA SOURCE:
=======================
Spot prices are published to Redis by `gift_nifty_gap.py` (in continuous mode):
    - index:NSENIFTY50      → NIFTY spot price (JSON with 'last_price')
    - index:NSENIFTYBANK    → BANKNIFTY spot price
    - index:BFOSENSEX       → SENSEX spot price
    - index:NSEINDIAVIX     → VIX value

SCRIPTS THAT USE THIS:
======================
    - zerodha/crawlers/intraday_crawler.py       → Updates spot prices from WS ticks
    - shared_core/multiprocess_pipeline.py       → Workers call connect_redis() + get_spot_price()
    - shared_core/calculation_service.py         → Uses get_spot_price() for Greek calculations
    - intraday_trading/intraday_scanner/scanner_main.py  → Market scanning
    - aion_trading_dashboard/backend/robot_order_executor.py → Trade execution

CONFIG REGENERATION:
====================
Run `update_intraday_crawler.py` to regenerate the config with current expiries/strikes.
"""

import json
import time
from dataclasses import dataclass
from typing import Dict, Optional, List
from functools import lru_cache
import threading
from pathlib import Path

@dataclass
class IndexConfig:
    """Lightweight index configuration"""
    symbol: str
    token: int
    spot_price_key: Optional[str] = None
    spot_price: float = 0.0
    last_update: float = 0.0
    futures: List[int] = None
    options: List[int] = None
    current_expiry: str = ""
    
    def __post_init__(self):
        if self.futures is None:
            self.futures = []
        if self.options is None:
            self.options = []

class IndexManager:
    """
    Centralized index price and mapping manager.
    
    THREAD-SAFE singleton that provides:
    - In-memory spot price cache (updated by websocket parser)
    - Redis fallback for downstream consumers (via connect_redis())
    - Token-to-index mapping for options/futures
    
    Usage:
        from shared_core.index_manager import index_manager
        
        # In worker processes, connect Redis for fallback:
        index_manager.connect_redis(redis_client)
        
        # Get spot price (tries memory first, then Redis):
        price = index_manager.get_spot_price("NIFTY")
        
        # Check if token belongs to an index:
        index_name = index_manager.get_index_for_token(token)
    """

    
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls, redis_client=None):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialize(redis_client)
        else:
            # Allow attaching redis instance later if needed
            if redis_client and not cls._instance.redis_client:
                cls._instance.redis_client = redis_client
        return cls._instance
    
    def _initialize(self, redis_client=None):
        self.indices: Dict[str, IndexConfig] = {}
        self.token_to_index: Dict[int, str] = {}
        self.spot_prices: Dict[str, float] = {}
        self.redis_client = redis_client
        self._load_config()
        
    def connect_redis(self, redis_client):
        """Attaches a Redis client for fallback lookups."""
        self.redis_client = redis_client
    
    def _load_config(self):
        """Load index configuration from intraday_crawler_instruments.json (Schema V2.0)"""
        try:
            # Load the index-centric config generated by update_intraday_crawler.py
            # Resolving path relative to project root usually
            project_root = Path(__file__).resolve().parent.parent
            config_path = project_root / "zerodha" / "crawlers" / "binary_crawler1" / "intraday_crawler_instruments.json"
            
            if not config_path.exists():
                # Try fallback location if project structure differs
                config_path = Path("/Users/lokeshgupta/Projects/aion_algo_trading/src/zerodha/crawlers/binary_crawler1/intraday_crawler_instruments.json")
            
            with open(config_path, 'r') as f:
                config = json.load(f)
            
            # Helper to access nested keys safely (V1/V2 compatibility)
            indices_data = config.get("indices", {})
            
            # Initialize indices
            for index_symbol, index_data in indices_data.items():
                # Handle both V2.0 (dict) and fallback
                if not isinstance(index_data, dict):
                    continue
                    
                index_config = IndexConfig(
                    symbol=index_symbol,
                    token=index_data.get("index_token"),
                    spot_price_key=index_data.get("spot_price_key"),
                    futures=index_data.get("futures", []),
                    options=index_data.get("options", []),
                    current_expiry=index_data.get("expiries", [""])[0] if index_data.get("expiries") else ""
                )
                self.indices[index_symbol] = index_config
                self.token_to_index[index_config.token] = index_symbol
                
                # Map all related tokens
                for fut_token in index_config.futures:
                    self.token_to_index[fut_token] = index_symbol
                for opt_token in index_config.options:
                    self.token_to_index[opt_token] = index_symbol
                    
        except Exception as e:
            print(f"IndexManager Load Error: {e}")
            # Fallback to hardcoded indices
            fallback_indices = {
                "NIFTY": {"token": 256265, "key": "index:NSENIFTY50"},
                "BANKNIFTY": {"token": 260105, "key": "index:NSENIFTYBANK"},
                "SENSEX": {"token": 265, "key": "index:BFOSENSEX"}
            }
            for symbol, data in fallback_indices.items():
                self.indices[symbol] = IndexConfig(
                    symbol=symbol, 
                    token=data["token"],
                    spot_price_key=data.get("key")
                )
                self.token_to_index[data["token"]] = symbol
    
    def update_spot_price(self, token: int, price: float):
        """Update index spot price (called by websocket parser)"""
        if token in self.token_to_index:
            index_symbol = self.token_to_index[token]
            # Only update if this is the pure index token
            if self.is_index_token(token):
                self.spot_prices[index_symbol] = price
                self.indices[index_symbol].spot_price = price
                self.indices[index_symbol].last_update = time.time()
    
    def get_spot_price(self, index_symbol: str) -> Optional[float]:
        """
        Get current spot price for an index.
        
        Priority:
        1. In-memory cache (fastest)
        2. Redis DB1 with multiple key patterns
        3. Disk fallback: gift_nifty_gap JSONL file
        """
        sym = index_symbol.upper()
        
        # 1. Check Memory cache first (fastest)
        price = self.spot_prices.get(sym)
        if price is not None and price > 0:
            return price
        
        # 2. Try Redis DB1 with multiple key patterns
        if self.redis_client:
            price = self._get_price_from_redis(sym)
            if price and price > 0:
                self.spot_prices[sym] = price
                return price
        
        # 3. Fallback: Read from gift_nifty_gap JSONL file on disk
        price = self._get_price_from_jsonl(sym)
        if price and price > 0:
            self.spot_prices[sym] = price
            return price
        
        return None
    
    def _get_price_from_redis(self, sym: str) -> Optional[float]:
        """Try multiple Redis key patterns for index price."""
        if not self.redis_client:
            return None
        
        # Build list of possible Redis keys for this index
        # gift_nifty_gap writes to index:{exchange_prefix}{symbol}
        key_patterns = []
        
        # 1. Try configured spot_price_key first
        idx = self.indices.get(sym)
        if idx and idx.spot_price_key:
            key_patterns.append(idx.spot_price_key)
        
        # 2. Standard key patterns and aliases (Expanded for robustness)
        # NIFTY 50
        if sym in ("NIFTY", "NIFTY50", "NIFTY 50", "NSE NIFTY", "NSENIFTY", "NIFTY 50 INDEX"):
            key_patterns.extend(["index:NSENIFTY50", "index:NSENIFTY 50", "index:NIFTY 50"])
            
        # BANK NIFTY
        elif sym in ("BANKNIFTY", "NIFTYBANK", "NIFTY BANK", "NSE BANK NIFTY", "NSEBANKNIFTY", "BANK NIFTY", "BANKNIFTY INDEX"):
            key_patterns.extend(["index:NSENIFTYBANK", "index:NSENIFTY BANK", "index:BANKNIFTY"])
            
        # SENSEX
        elif sym in ("SENSEX", "BSE SENSEX", "BSESENSEX", "SENSEX INDEX"):
            key_patterns.extend(["index:BFOSENSEX", "index:BSESENSEX", "index:SENSEX"])
            
        # VIX
        elif sym in ("INDIAVIX", "VIX", "INDIA VIX", "NSE INDIA VIX", "NSEINDIAVIX"):
            key_patterns.extend(["index:NSEINDIAVIX", "index:NSEINDIA VIX", "index:INDIAVIX"])
        
        # 3. Generic patterns
        key_patterns.extend([
            f"index:{sym}",
            f"index:NSE{sym}",
            f"index:BFO{sym}",
        ])
        
        # Try each key pattern
        for key in key_patterns:
            try:
                val = self.redis_client.get(key)
                if val:
                    if isinstance(val, bytes):
                        val = val.decode('utf-8')
                    
                    # Try parsing as JSON (gift_nifty_gap format)
                    try:
                        data = json.loads(val)
                        if isinstance(data, dict) and 'last_price' in data:
                            return float(data['last_price'])
                    except (json.JSONDecodeError, TypeError):
                        pass
                    
                    # Try direct float parse
                    try:
                        return float(val)
                    except (ValueError, TypeError):
                        pass
            except Exception:
                continue
        
        return None
    
    def _get_price_from_jsonl(self, sym: str) -> Optional[float]:
        """Fallback: Read latest price from gift_nifty_gap JSONL file."""
        from datetime import datetime
        
        try:
            # JSONL file path: data/wal/gift_nifty_gap/indices_data_{date}.jsonl
            project_root = Path(__file__).resolve().parent.parent
            today = datetime.now().strftime("%Y%m%d")
            jsonl_path = project_root / "data" / "wal" / "gift_nifty_gap" / f"indices_data_{today}.jsonl"
            
            if not jsonl_path.exists():
                return None
            
            # Symbol mapping for JSONL lookup
            symbol_mappings = {
                "NIFTY": ["NSE:NIFTY 50", "NIFTY 50"],
                "NIFTY50": ["NSE:NIFTY 50", "NIFTY 50"],
                "NIFTY 50": ["NSE:NIFTY 50", "NIFTY 50"],
                "BANKNIFTY": ["NSE:NIFTY BANK", "NIFTY BANK"],
                "NIFTYBANK": ["NSE:NIFTY BANK", "NIFTY BANK"],
                "NIFTY BANK": ["NSE:NIFTY BANK", "NIFTY BANK"],
                "SENSEX": ["BSE:SENSEX", "SENSEX"],
                "INDIAVIX": ["NSE:INDIA VIX", "INDIA VIX"],
                "VIX": ["NSE:INDIA VIX", "INDIA VIX"],
                "INDIA VIX": ["NSE:INDIA VIX", "INDIA VIX"],
            }
            
            target_symbols = symbol_mappings.get(sym, [sym, f"NSE:{sym}"])
            
            # Read last few lines of JSONL (most recent data)
            with open(jsonl_path, 'r') as f:
                # Read last 20 lines (efficient for large files)
                lines = f.readlines()[-20:]
            
            for line in reversed(lines):
                try:
                    data = json.loads(line.strip())
                    line_symbol = data.get('symbol', '')
                    trading_symbol = data.get('tradingsymbol', '')
                    
                    if line_symbol in target_symbols or trading_symbol in target_symbols:
                        price = data.get('last_price')
                        if price and float(price) > 0:
                            return float(price)
                except (json.JSONDecodeError, KeyError, TypeError):
                    continue
                    
        except Exception:
            pass
        
        return None

    
    def get_index_for_token(self, token: int) -> Optional[str]:
        """Get index symbol for any instrument token"""
        return self.token_to_index.get(token)
    
    def is_index_token(self, token: int) -> bool:
        """Check if token is a pure index token"""
        index_symbol = self.get_index_for_token(token)
        if not index_symbol:
            return False
        return token == self.indices[index_symbol].token
    
    def get_all_index_tokens(self) -> List[int]:
        """Get all pure index tokens"""
        return [idx.token for idx in self.indices.values()]
    
    def get_index_futures(self, index_symbol: str) -> List[int]:
        """Get futures tokens for an index"""
        idx = self.indices.get(index_symbol.upper())
        return idx.futures if idx else []
    
    def get_index_options(self, index_symbol: str) -> List[int]:
        """Get options tokens for an index"""
        idx = self.indices.get(index_symbol.upper())
        return idx.options if idx else []

# Global singleton instance
index_manager = IndexManager()
